use anyhow::Result;
use binrw::BinRead;
use paris::{error, info, success, warn};
use std::fs::File;

#[cfg(unix)]
use std::{fs::Permissions, os::unix::prelude::PermissionsExt};

use std::io::{prelude::Write, Cursor};
use std::path::{Path, PathBuf};
use std::process::exit;
use std::{env, fs};

mod archiver;
mod erlang_launcher;
mod errors;
mod release;

use crate::archiver::{FoilzFileRecord, FoilzPayload};
use crate::errors::{ExtractError, WrapperError};
use release::Release;

pub const IS_PROD: bool = !option_env!("IS_PROD").is_none();
pub const RELEASE_NAME: &str = env!("RELEASE_NAME");
pub const RELEASE_METADATA_STR: &str = env!("RELEASE_METADATA");

// Simple macro to only run a code block if IS_PROD is false
macro_rules! if_debug {
    ($body:block) => {
        if (!IS_PROD) {
            $body
        }
    };
}

fn main() {
    let _ = exec().map_err(|err| {
        error!("{}", err);
        exit(1);
    });

    exit(0)
}

fn exec() -> Result<(), WrapperError> {
    // If on windows, enable ANSI support so we can have color output
    // Windows 10+ only
    if cfg!(windows) {
        let _ = enable_ansi_support::enable_ansi_support();
    }

    let args: Vec<String> = env::args().skip(1).collect();
    if_debug!({
        info!("IS_PROD={}", IS_PROD);
        info!("RELEASE_NAME={}", RELEASE_NAME);
        info!("ARGS={:?}", args);
        info!("METADATA_STRING={}", RELEASE_METADATA_STR);
    });

    let release = Release::new(RELEASE_NAME, RELEASE_METADATA_STR)?;

    let install_dir = release.install_dir();

    // If the directory does not exist, we need to install
    let mut needs_install = determine_needs_install(&install_dir);

    if_debug!({
        info!("INSTALL_DIR={}", install_dir.display());
        info!("NEEDS_INSTALL={}", needs_install);
        warn!("HEADS UP: We're ALWAYS going to re-install in debug mode!");
        needs_install = true;
    });

    // If we need to install, decompress, and unpack the payload to disk
    if needs_install {
        decompress_payload(&install_dir)?;
    }

    // Now launch!
    erlang_launcher::launch_app(&release, &args)?;

    Ok(())
}

fn decompress_payload(destination_path: &PathBuf) -> Result<(), ExtractError> {
    // Embed and decompress payload
    // Payload is present at compile time, it's generated by the `build.rs` file in the top level of the crate
    let payload = include_bytes!("../payload.foilz.xz");
    let mut decompressor = snap::raw::Decoder::new();
    let decompressed_data = decompressor
        .decompress_vec(payload)
        .map_err(|_| ExtractError::PayloadDecompressError)?;

    // Read the decompressed stream into structs
    let parsed_payload: FoilzPayload = FoilzPayload::read_be(&mut Cursor::new(&decompressed_data))
        .map_err(|_| ExtractError::PayloadParseError)?;

    // Write each record to disk
    for record in parsed_payload.files {
        write_payload_file(&record, &destination_path)?;
    }

    if_debug!({
        success!(
            "Finished payload decompression! Uncompressed size: {}",
            decompressed_data.len()
        );
    });

    Ok(())
}

fn write_payload_file(
    record: &FoilzFileRecord,
    destination_path: &PathBuf,
) -> Result<(), ExtractError> {
    // Compute full destination path of this file
    let mut full_path: PathBuf = destination_path.clone();
    let dest_name: PathBuf = Path::new(&record.file_path.to_string()).to_path_buf();
    full_path.push(dest_name);

    // Compute parent path of install
    let parent_path = full_path
        .parent()
        .ok_or(ExtractError::InvalidInstallDirError)?;

    // Create all directories needed for placing this file
    fs::create_dir_all(parent_path).map_err(|err| ExtractError::MkdirError(err))?;

    // Create the file
    let mut new_file =
        File::create(&full_path).map_err(|err| ExtractError::FileCreateError(err))?;

    // Write file data
    new_file
        .write_all(&record.file_data)
        .map_err(|err| ExtractError::FileWriteError(err))?;

    if_debug!({
        success!("Wrote File: {}", full_path.display());
    });

    // Set file mode if NOT on Windows
    #[cfg(unix)]
    {
        let perm: Permissions = Permissions::from_mode(record.file_mode);

        new_file
            .set_permissions(perm)
            .map_err(|err| ExtractError::ChmodError(err))?;

        if_debug!({
            info!(
                "\tSet perm {:#o} -> {}",
                record.file_mode,
                full_path.display()
            );
        });
    }

    Ok(())
}

fn determine_needs_install(full_install_dir: &PathBuf) -> bool {
    !full_install_dir.exists()
}
