use anyhow::Result;
use archiver::PayloadMetadata;
use binrw::BinRead;
use paris::{error, info, success, warn};
use std::fs::File;

#[cfg(unix)]
use std::{fs::Permissions, os::unix::prelude::PermissionsExt};

use std::io::{prelude::Write, Cursor};
use std::path::{Path, PathBuf};
use std::process::exit;
use std::{env, fs};

mod archiver;
mod erlang_launcher;
mod errors;

use crate::archiver::{FoilzFileRecord, FoilzPayload};
use crate::errors::{ExtractError, MetadataError, WrapperError};

pub const IS_PROD: bool = !option_env!("IS_PROD").is_none();
pub const RELEASE_NAME: &str = env!("RELEASE_NAME");
pub const RELEASE_METADATA_STR: &str = env!("RELEASE_METADATA");

pub const INSTALL_SUFFIX: &str = ".burrito";

// Simple macro to only run a code block if IS_PROD is false
macro_rules! if_debug {
    ($body:block) => {
        if (!IS_PROD) {
            $body
        }
    };
}

fn main() {
    let _ = exec().map_err(|err| {
        error!("{}", err);
        exit(1);
    });

    exit(0)
}

fn exec() -> Result<(), WrapperError> {
    // If on windows, enable ANSI support so we can have color output
    // Windows 10+ only
    if cfg!(windows) {
        let _ = enable_ansi_support::enable_ansi_support();
    }

    let args: Vec<String> = env::args().skip(1).collect();
    if_debug!({
        info!("IS_PROD={}", IS_PROD);
        info!("RELEASE_NAME={}", RELEASE_NAME);
        info!("ARGS={:?}", args);
        info!("METADATA_STRING={}", RELEASE_METADATA_STR);
    });

    // Bit of a nasty hack to get a mutable global metadata struct...
    // Probably a better way to do this!
    let release_meta =
        maybe_parse_metadata().map_err(|err| WrapperError::ParseMetadataError(err))?;

    // Compute install directory
    let install_dir = get_install_dir(&release_meta)
        .map_err(|err| WrapperError::ComputeInstallDirectoryError(err))?;

    // If the directory does not exist, we need to install
    let mut needs_install = determine_needs_install(&install_dir);

    if_debug!({
        info!("INSTALL_DIR={}", install_dir.display());
        info!("NEEDS_INSTALL={}", needs_install);
        warn!("HEADS UP: We're ALWAYS going to re-install in debug mode!");
        needs_install = true;
    });

    // If we need to install, decompress, and unpack the payload to disk
    if needs_install {
        decompress_payload(&install_dir)
            .map_err(|err| WrapperError::DecompressPayloadError(err))?;
    }

    // Now launch!
    erlang_launcher::launch_app(&install_dir, &release_meta, &args)
        .map_err(|err| WrapperError::LaunchError(err))?;

    Ok(())
}

fn maybe_parse_metadata() -> Result<PayloadMetadata, MetadataError> {
    serde_json::from_str(RELEASE_METADATA_STR).map_err(|_| MetadataError::CorruptedError)
}

fn decompress_payload(destination_path: &Path) -> Result<(), ExtractError> {
    // Embed and decompress payload
    // Payload is present at compile time, it's generated by the `build.rs` file in the top level of the crate
    let payload = include_bytes!("../payload.foilz.xz");
    let mut decompressor = snap::raw::Decoder::new();
    let decompressed_data = decompressor
        .decompress_vec(payload)
        .map_err(|_| ExtractError::PayloadDecompressError)?;

    // Read the decompressed stream into structs
    let parsed_payload: FoilzPayload = FoilzPayload::read_be(&mut Cursor::new(&decompressed_data))
        .map_err(|_| ExtractError::PayloadParseError)?;

    // Write each record to disk
    for record in parsed_payload.files {
        write_payload_file(&record, &destination_path)?;
    }

    if_debug!({
        success!(
            "Finished payload decompression! Uncompressed size: {}",
            decompressed_data.len()
        );
    });

    Ok(())
}

fn write_payload_file(
    record: &FoilzFileRecord,
    destination_path: &Path,
) -> Result<(), ExtractError> {
    // Compute full destination path of this file
    let mut full_path: PathBuf = destination_path.clone().to_path_buf();
    let dest_name: PathBuf = Path::new(&record.file_path.to_string()).to_path_buf();
    full_path.push(dest_name);

    // Compute parent path of install
    let parent_path = full_path
        .parent()
        .ok_or(ExtractError::InvalidInstallDirError)?;

    // Create all directories needed for placing this file
    fs::create_dir_all(parent_path).map_err(|err| ExtractError::MkdirError(err))?;

    // Create the file
    let mut new_file =
        File::create(&full_path).map_err(|err| ExtractError::FileCreateError(err))?;

    // Write file data
    new_file
        .write_all(&record.file_data)
        .map_err(|err| ExtractError::FileWriteError(err))?;

    if_debug!({
        success!("Wrote File: {}", full_path.display());
    });

    // Set file mode if NOT on Windows
    #[cfg(unix)]
    {
        let perm: Permissions = Permissions::from_mode(record.file_mode);

        new_file
            .set_permissions(perm)
            .map_err(|err| ExtractError::ChmodError(err))?;

        if_debug!({
            info!(
                "\tSet perm {:#o} -> {}",
                record.file_mode,
                full_path.display()
            );
        });
    }

    Ok(())
}

fn determine_needs_install(full_install_dir: &Path) -> bool {
    !full_install_dir.exists()
}

fn get_install_dir(release_meta: &PayloadMetadata) -> Result<PathBuf, ExtractError> {
    let install_dir_env_name = format!("{}_INSTALL_PATH", RELEASE_NAME);

    let release_suffix = format!(
        "{}_erts-{}_{}",
        RELEASE_NAME, release_meta.erts_version, release_meta.app_version
    );

    let possible_env_override = env::var(install_dir_env_name).map(|path_override| {
        info!(
            "Install path is being overridden using env var: {}_INSTALL_PATH",
            RELEASE_NAME
        );
        info!("New install path is: {}", path_override);

        Path::new(&path_override).to_path_buf()
    });

    let fallback_to_default_base_dir =
        |_| dirs::data_dir().ok_or(ExtractError::CannotComputeInstallDirError);

    let mut path = possible_env_override.or_else(fallback_to_default_base_dir)?;

    path.push(INSTALL_SUFFIX);
    path.push(release_suffix);
    Ok(path)
}
