use anyhow::Result;
use binrw::BinRead;
use std::fs::File;

use std::process::exit;
#[cfg(unix)]
use std::{fs::Permissions, os::unix::prelude::PermissionsExt};

use std::io::{prelude::Write, Cursor};
use std::path::{Path, PathBuf};
use std::{env, fs};

mod archiver;
mod console;
mod erlang_launcher;
mod errors;
mod maintenance;
mod release;

use crate::archiver::{FoilzFileRecord, FoilzPayload};
use crate::errors::{ExtractError, WrapperError};
use console::{error, info, log, success, warn, StandardIO, StandardIOConfig, IO};
use release::Release;

pub const IS_PROD: bool = !option_env!("IS_PROD").is_none();

// Simple macro to only run a code block if IS_PROD is false
macro_rules! if_debug {
    ($($tokens:tt)*) => {
        if (!IS_PROD) {
            $($tokens)*
        }
    };
}

fn main() {
    // If on windows, enable ANSI support so we can have color output
    // Windows 10+ only
    let color = console::try_enable_stdout_color();

    let mut io = StandardIO::new(StandardIOConfig {
        color,
        ..StandardIO::DEFAULT
    });

    let result = maintenance::uninstall(&mut io);

    match result {
        Err(err) => {
            error!(io, "{}", err);
            ()
        }
        Ok(()) => (),
    }

    let _ = exec(&mut io).map_err(|err| {
        error!(io, "{}", err);
        exit(1);
    });

    // exit(0)
}

fn exec<I: IO>(io: &mut I) -> Result<(), WrapperError> {
    let args: Vec<String> = env::args().skip(1).collect();

    if_debug! {
        log!(io, "<variable>IS_PROD={}</>", IS_PROD);
        log!(io, "<variable>RELEASE_NAME={}</>", release::RELEASE_NAME);
        log!(io, "<variable>ARGS={:?}</>", args);
        log!(
            io,
            "<variable>METADATA_STRING={}</>",
            release::RELEASE_METADATA_STR
        );
    };

    let release = Release::load(io)?;

    let install_dir = release.install_dir();

    // If the directory does not exist, we need to install
    let mut needs_install = determine_needs_install(&install_dir);

    if_debug! {
        log!(io, "<variable>INSTALL_DIR={}</>", install_dir.display());
        log!(io, "<variable>NEEDS_INSTALL={}</>", needs_install);
        warn!(
            io,
            "HEADS UP: We're ALWAYS going to re-install in debug mode!"
        );
        needs_install = true;
    }

    // If we need to install, decompress, and unpack the payload to disk
    if needs_install {
        decompress_payload(io, &install_dir)?;
    }

    // Now launch!
    erlang_launcher::launch_app(&release, &args)?;

    Ok(())
}

fn decompress_payload<I: IO>(io: &mut I, destination_path: &Path) -> Result<(), ExtractError> {
    // Embed and decompress payload
    // Payload is present at compile time, it's generated by the `build.rs` file in the top level of the crate
    let payload = include_bytes!("../payload.foilz.xz");
    let mut decompressor = snap::raw::Decoder::new();
    let decompressed_data = decompressor
        .decompress_vec(payload)
        .map_err(|_| ExtractError::PayloadDecompressError)?;

    // Read the decompressed stream into structs
    let parsed_payload: FoilzPayload = FoilzPayload::read_be(&mut Cursor::new(&decompressed_data))
        .map_err(|_| ExtractError::PayloadParseError)?;

    // Write each record to disk
    for record in parsed_payload.files {
        write_payload_file(io, &record, destination_path)?;
    }

    if_debug! {
        success!(
            io,
            "Finished payload decompression! Uncompressed size: {}",
            decompressed_data.len()
        );
    }

    Ok(())
}

fn write_payload_file<I: IO>(
    io: &mut I,
    record: &FoilzFileRecord,
    destination_path: &Path,
) -> Result<(), ExtractError> {
    // Compute full destination path of this file
    let mut full_path: PathBuf = destination_path.to_path_buf();
    let dest_name: PathBuf = Path::new(&record.file_path.to_string()).to_path_buf();
    full_path.push(dest_name);

    success!(io, "test {full_path:?} test");

    // Compute parent path of install
    let parent_path = full_path
        .parent()
        .ok_or(ExtractError::InvalidInstallDirError)?;

    // Create all directories needed for placing this file
    fs::create_dir_all(parent_path).map_err(|err| ExtractError::MkdirError(err))?;

    // Create the file
    let mut new_file =
        File::create(&full_path).map_err(|err| ExtractError::FileCreateError(err))?;

    // Write file data
    new_file
        .write_all(&record.file_data)
        .map_err(|err| ExtractError::FileWriteError(err))?;

    if_debug! {
        success!(io, "Wrote File: {}", full_path.display());
    }

    // Set file mode if NOT on Windows
    #[cfg(unix)]
    {
        let perm: Permissions = Permissions::from_mode(record.file_mode);

        new_file
            .set_permissions(perm)
            .map_err(|err| ExtractError::ChmodError(err))?;

        if_debug! {
            io.indent(1);
            info!(
                io,
                "Set perm {:#o} -> {}",
                record.file_mode,
                full_path.display()
            );
        }
    }

    Ok(())
}

fn determine_needs_install(full_install_dir: &Path) -> bool {
    !full_install_dir.exists()
}
